<div class="space-y-8">
  <h2 class="text-2xl font-bold">Native Federation for Micro-Frontends</h2>
  
  <div class="bg-blue-50 border border-blue-200 text-blue-800 p-4 rounded-lg">
    <strong>Note:</strong> This application simulates a micro-frontend (MFE) architecture by lazy-loading components. This screen explains the concepts of <strong>Native Federation</strong>, which would be used to build a true MFE in a production environment.
  </div>

  <!-- Core Concepts -->
  <div class="bg-white p-6 rounded-lg border border-gray-200 space-y-4">
    <h3 class="font-semibold text-xl">Core Concepts</h3>
    <p>Native Federation leverages browser-native ES Modules, removing the dependency on Webpack-specific logic and making the architecture more standardized and future-proof.</p>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
      <div class="p-4 bg-gray-50 rounded-md">
        <h4 class="font-bold">Host (Shell)</h4>
        <p class="text-sm">The main application that orchestrates and renders remotes. It contains the primary navigation and layout.</p>
      </div>
      <div class="p-4 bg-gray-50 rounded-md">
        <h4 class="font-bold">Remote</h4>
        <p class="text-sm">A separately deployed application (a micro-frontend) that exposes modules for the host to consume.</p>
      </div>
      <div class="p-4 bg-gray-50 rounded-md">
        <h4 class="font-bold">Manifest</h4>
        <p class="text-sm">A <code>federation.manifest.json</code> file published by a remote. It acts as a contract, listing the name, version, and exposed modules.</p>
      </div>
    </div>
    <app-code-snippet [code]="manifestSnippet"></app-code-snippet>
  </div>

  <!-- Possibilities -->
  <div class="space-y-6">
    <!-- Possibility 1: Lazy Loading -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h3 class="font-semibold text-xl mb-2">Possibility 1: Lazy Loading Components & Routes</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="prose max-w-none">
          <p>This is the primary use case. The host application can lazy-load a component or an entire set of routes from a remote MFE. This keeps the initial bundle small and allows teams to develop and deploy their features independently.</p>
          <h4>Why it matters</h4>
          <ul>
            <li><strong>Decoupling:</strong> Teams can work on their remotes in isolation.</li>
            <li><strong>Performance:</strong> Users only download the code for the features they access.</li>
            <li><strong>Scalability:</strong> Easily add new features by creating and linking new remotes.</li>
          </ul>
        </div>
        <div>
          <app-code-snippet [code]="hostRoutingSnippet"></app-code-snippet>
        </div>
      </div>
    </div>

    <!-- Possibility 2: Sharing Libraries -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h3 class="font-semibold text-xl mb-2">Possibility 2: Sharing Libraries</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="prose max-w-none">
          <p>To avoid duplicating common dependencies (like Angular, RxJS, or component libraries) in every remote's bundle, you can configure them as shared libraries. Native Federation ensures that only one instance of a shared library is loaded on the page.</p>
          <h4>Why it matters</h4>
          <ul>
            <li><strong>Efficiency:</strong> Drastically reduces total download size for the user.</li>
            <li><strong>Consistency:</strong> Using <code>singleton: true</code> ensures a single instance of a library, preventing version conflicts and unexpected behavior.</li>
          </ul>
        </div>
        <div>
          <app-code-snippet [code]="sharedLibsSnippet"></app-code-snippet>
        </div>
      </div>
    </div>

    <!-- Possibility 3: Sharing State -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h3 class="font-semibold text-xl mb-2">Advanced Possibility 3: Sharing State</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="prose max-w-none">
          <p>Communicating between remotes is a common challenge. A robust pattern is to create a dedicated "common" remote that exposes a shared state service (e.g., using signals or a state management library). The host loads this service and provides it, making it available for dependency injection in other remotes.</p>
          <h4>Why it matters</h4>
          <ul>
            <li><strong>Centralized Logic:</strong> Provides a single source of truth for shared application state.</li>
            <li><strong>Type-Safe Communication:</strong> Avoids fragile methods like browser events or the window object.</li>
          </ul>
        </div>
        <div>
          <app-code-snippet [code]="sharedStateSnippet"></app-code-snippet>
        </div>
      </div>
    </div>
    
    <!-- Possibility 4: Dynamic Federation -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h3 class="font-semibold text-xl mb-2">Advanced Possibility 4: Dynamic Federation</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="prose max-w-none">
          <p>In highly dynamic applications, you may not know which remotes to load at build time. Dynamic federation allows you to fetch a remote's manifest from a server at runtime, initialize it, and then load its modules. This is perfect for plugin-based architectures or systems where features are enabled based on user permissions.</p>
          <h4>Why it matters</h4>
          <ul>
            <li><strong>Ultimate Flexibility:</strong> Build systems where new micro-frontends can be added without rebuilding or redeploying the host application.</li>
            <li><strong>Custom User Experiences:</strong> Tailor the application's functionality by loading different sets of remotes for different users.</li>
          </ul>
        </div>
        <div>
          <app-code-snippet [code]="dynamicFederationSnippet"></app-code-snippet>
        </div>
      </div>
    </div>
  </div>

  <!-- Best Practices -->
  <div class="space-y-6">
    <h3 class="text-xl font-bold border-t pt-6 mt-6 border-gray-200">Top 5 Best Practices for MFE with Angular & Native Federation</h3>
  
    <!-- Practice 1 -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h4 class="font-semibold text-lg">1. Isolate Remotes & Define Clear APIs</h4>
      <p class="mt-2 text-gray-700">Treat each remote as a black box. It should be self-contained and expose a well-defined public API (e.g., component inputs, exposed services). Avoid direct dependencies between remotes; all communication should flow through the host or a shared service. Using Standalone Components makes this isolation clearer, as all dependencies are explicitly listed in the component's <code>imports</code> array.</p>
      <p class="mt-2 text-sm font-semibold text-gray-600"><strong>How it avoids bugs:</strong> Changes within one remote won't accidentally break another, as long as the public API contract is respected. This allows teams to iterate independently with confidence.</p>
    </div>
  
    <!-- Practice 2 -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h4 class="font-semibold text-lg">2. Manage Shared Dependencies Strictly</h4>
      <p class="mt-2 text-gray-700">Use the <code>shared</code> configuration in Native Federation to ensure only one instance of core libraries (like <code>@angular/core</code>, <code>rxjs</code>) is loaded. Always configure them as singletons with strict versioning. This prevents subtle bugs caused by version mismatches or multiple instances of stateful libraries.</p>
      <p class="mt-2 text-sm font-semibold text-gray-600"><strong>How it avoids bugs:</strong> Guarantees a stable and predictable runtime environment, eliminating issues where, for example, <code>instanceof</code> checks fail because an object comes from a different library instance.</p>
    </div>
  
    <!-- Practice 3 -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h4 class="font-semibold text-lg">3. Centralize Cross-MFE State with Signal-based Services</h4>
      <p class="mt-2 text-gray-700">For state that needs to be shared across remotes, create a dedicated "common" remote that exposes singleton services. Build these services with Angular Signals. This provides a highly efficient, fine-grained, and predictable way for different parts of your application to react to state changes without resorting to fragile solutions like window events.</p>
      <p class="mt-2 text-sm font-semibold text-gray-600"><strong>How it avoids bugs:</strong> Creates a single source of truth and a clear, type-safe data flow, making state changes easy to trace and debug.</p>
    </div>
  
    <!-- Practice 4 -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h4 class="font-semibold text-lg">4. Implement Versioned Deployments & Immutable Artifacts</h4>
      <p class="mt-2 text-gray-700">Your CI/CD pipeline for each remote should publish its build artifacts (JS files, manifest) to a unique, versioned path (e.g., <code>/remotes/my-feature/1.2.0/</code>). Never overwrite a previous version's artifacts.</p>
      <ul class="mt-4 space-y-2 text-gray-700 list-disc list-inside">
        <li><strong>How to deploy a new version:</strong> Build the remote, deploy its artifacts to a new versioned path, and update the host's manifest mapping to point to the new <code>federation.manifest.json</code> URL. This can be managed via a configuration file or a dynamic lookup service.</li>
        <li><strong>How to restore an old version:</strong> Because old artifacts are immutable and still available, rolling back is as simple as changing the manifest URL back to the previous, stable version. This process is nearly instantaneous and has minimal risk.</li>
      </ul>
      <app-code-snippet [code]="versionedDeploymentSnippet"></app-code-snippet>
    </div>
  
    <!-- Practice 5 -->
    <div class="bg-white p-6 rounded-lg border border-gray-200">
      <h4 class="font-semibold text-lg">5. Design for Resilience and Independent Testability</h4>
      <p class="mt-2 text-gray-700">The host application should be resilient to a remote failing to load. Use features like the <code>&#64;error</code> block in <code>&#64;defer</code> or error handlers in your routing configuration to gracefully handle cases where a remote is unavailable. Furthermore, each remote should be fully testable in isolation. It should have its own development shell or harness to allow developers to run, test, and debug it without needing the entire host application.</p>
      <p class="mt-2 text-sm font-semibold text-gray-600"><strong>How it avoids bugs:</strong> Prevents a single failing MFE from taking down the entire application. Independent testing catches bugs earlier in the development cycle, long before integration.</p>
    </div>
  </div>
</div>